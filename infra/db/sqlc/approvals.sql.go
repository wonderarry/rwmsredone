// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: approvals.sql

package sqlc

import (
	"context"
)

const countApprovalByDecisionAndRole = `-- name: CountApprovalByDecisionAndRole :one
SELECT COUNT(*)
FROM approvals
WHERE process_id = $1
  AND stage_key  = $2
  AND by_role    = $3
  AND decision   = $4
`

type CountApprovalByDecisionAndRoleParams struct {
	ProcessID string `json:"process_id"`
	StageKey  string `json:"stage_key"`
	ByRole    string `json:"by_role"`
	Decision  string `json:"decision"`
}

func (q *Queries) CountApprovalByDecisionAndRole(ctx context.Context, arg CountApprovalByDecisionAndRoleParams) (int64, error) {
	row := q.db.QueryRow(ctx, countApprovalByDecisionAndRole,
		arg.ProcessID,
		arg.StageKey,
		arg.ByRole,
		arg.Decision,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const listApprovalsByProcessAndStage = `-- name: ListApprovalsByProcessAndStage :many
SELECT process_id, stage_key, by_account_id, by_role, decision, comment, created_at
FROM approvals
WHERE process_id = $1 AND stage_key = $2
ORDER BY created_at ASC
`

type ListApprovalsByProcessAndStageParams struct {
	ProcessID string `json:"process_id"`
	StageKey  string `json:"stage_key"`
}

func (q *Queries) ListApprovalsByProcessAndStage(ctx context.Context, arg ListApprovalsByProcessAndStageParams) ([]Approval, error) {
	rows, err := q.db.Query(ctx, listApprovalsByProcessAndStage, arg.ProcessID, arg.StageKey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Approval
	for rows.Next() {
		var i Approval
		if err := rows.Scan(
			&i.ProcessID,
			&i.StageKey,
			&i.ByAccountID,
			&i.ByRole,
			&i.Decision,
			&i.Comment,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertApproval = `-- name: UpsertApproval :exec
INSERT INTO approvals (process_id, stage_key, by_account_id, by_role, decision, comment, created_at)
VALUES ($1, $2, $3, $4, $5, $6, now())
ON CONFLICT (process_id, stage_key, by_account_id)
DO UPDATE SET decision = EXCLUDED.decision,
              comment  = EXCLUDED.comment,
              created_at = now()
`

type UpsertApprovalParams struct {
	ProcessID   string `json:"process_id"`
	StageKey    string `json:"stage_key"`
	ByAccountID string `json:"by_account_id"`
	ByRole      string `json:"by_role"`
	Decision    string `json:"decision"`
	Comment     string `json:"comment"`
}

func (q *Queries) UpsertApproval(ctx context.Context, arg UpsertApprovalParams) error {
	_, err := q.db.Exec(ctx, upsertApproval,
		arg.ProcessID,
		arg.StageKey,
		arg.ByAccountID,
		arg.ByRole,
		arg.Decision,
		arg.Comment,
	)
	return err
}
